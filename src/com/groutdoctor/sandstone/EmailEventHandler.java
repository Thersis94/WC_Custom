package com.groutdoctor.sandstone;

import java.io.IOException;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.ObjectMessage;

import com.siliconmtn.security.EncryptionException;
import com.siliconmtn.http.parser.StringEncoder;
import com.siliconmtn.io.mail.MessageVO;
import com.siliconmtn.io.mail.MessageVO.State;
import com.siliconmtn.io.http.SMTHttpConnectionManager;
import com.siliconmtn.sb.jms.AbstractMessageHandler;
import com.siliconmtn.security.StringEncrypter;
import com.siliconmtn.util.StringUtil;

/***************************************************************************
 * <b>Title</b>: EmailEventHandler.java<p/>
 * <b>Description: </b> Listens to a special queue for SendGrid events related to Keystone (GroutStone) emails.
 * In turn makes an http call back to Keystone so it "gets the memo".
 * SendGrid dumps all events to WC; WC has to sort and redirect accordingly. 
 * <p/>
 * <b>Copyright:</b> Copyright (c) 2017<p/>
 * <b>Company:</b> Silicon Mountain Technologies<p/>
 * @author James McKain
 * @version 1.0
 * @since Nov 16, 2017
 ***************************************************************************/
public class EmailEventHandler extends AbstractMessageHandler {

	/*
	 * Recieves a message from the queue and enacts upon it.
	 * (non-Javadoc)
	 * @see javax.jms.MessageListener#onMessage(javax.jms.Message)
	 */
	@Override
	public void onMessage(Message message) {
		//tell the queue "we've got this".  From here forward if sending fails we'll deal with it internally.
		try {
			message.acknowledge();
		} catch (JMSException e) {
			log.warn("could not acknowledge message", e);
		}

		MessageVO msg = null;
		//cast the JMS Message to an SMT Message 
		try {
			ObjectMessage oMsg = (ObjectMessage) message;
			msg = (MessageVO) oMsg.getObject();
			log.debug("message id=" + msg.getMessageId() + " cast from Message to ObjectMessage to MessageVO");

		} catch (Exception e) {
			log.error("could not cast JMS Message to SMT Message", e);
			log.error("Handler was given an unexpected message: " + StringUtil.getToString(message));
			return;
		}

		sendKeystoneRequest(msg);
	}


	/**
	 * Crafts and delivers an http call to Keystone to related the SMTP event reported by SendGrid.
	 * @param msg
	 */
	protected void sendKeystoneRequest(MessageVO msg) {
		log.debug("sending event info to Keystone for: " + msg);
		String domain = (String) sc.getAttribute("keystone" + msg.getSource().toUpperCase());

		// If we didn't receive a valid domain there is no point sending out the request
		if(StringUtil.isEmpty(domain)) {
			log.error("Invalid msg source recieved: " + msg);
			return;
		} else if ("DEVELOPMENT".equalsIgnoreCase(msg.getSource())) {
			//not logging dev emails.
			return;
		}

		try {
			SMTHttpConnectionManager conn = new SMTHttpConnectionManager();
			conn.setFollowRedirects(false);
			conn.setConnectionTimeout(30000);
			conn.retrieveData(domain + buildParams(msg));

			//trap all errors generated by Keystone
			if (200 != conn.getResponseCode())
				throw new IOException("Transaction Unsuccessful, code=" + conn.getResponseCode() + ", msgId=" + msg.getMessageId());

		} catch (IOException ioe) {
			log.error(ioe.getMessage(), ioe);
		} catch (Exception e) {
			log.error(e.getMessage(), e);
		}
	}


	/**
	 * Assembles the http parameters for the GET request being sent to Keystone.
	 * @param msg
	 * @return
	 * @throws EncryptionException
	 */
	protected String buildParams(MessageVO msg) throws EncryptionException {
		StringEncrypter se = new StringEncrypter((String) sc.getAttribute("encryptKey"));
		String apiKey = "email:updateOutgoingMail:"+System.currentTimeMillis();
		apiKey = se.encrypt(apiKey);
		apiKey = StringEncoder.urlEncode(apiKey);

		StringBuilder params = new StringBuilder(250);
		params.append("?module=email");
		params.append("&action=updateOutgoingMail");
		params.append("&doJson=true");
		params.append("&sent_email_id="+ msg.getMessageId());
		params.append("&event="+ msg.getState());
		params.append("&APIKEY=" + apiKey);

		// If this is a bounced message we need to put the reason for the bounce on the request
		if (State.BOUNCED == msg.getState() || State.DROPPED == msg.getState())
			params.append("&reason=" + StringEncoder.urlEncode(msg.getErrorString()));

		return params.toString();
	}
}